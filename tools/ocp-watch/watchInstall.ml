(***********************************************************************)
(*                                                                     *)
(*                             ocp-watch                               *)
(*                                                                     *)
(*  Copyright 2012 OCamlPro SAS                                        *)
(*  Developed by OCamlPro, supervised by Fabrice LE FESSANT (INRIA)    *)
(*                                                                     *)
(***********************************************************************)

open Subcommands.TYPES

open WatchFunctions

(* We should replace calls to vfork() by a call to fork() *)

let function_prototypes oc functions =
  Printf.bprintf oc "\n\n/* autogenerated code */ \n\n";
  Array.iter (fun (result_type, fun_name, args, flags) ->
    Printf.bprintf oc
      "static %s (*libc_%s) (" result_type fun_name;
    begin
      match args with
        [] -> Printf.bprintf oc "void"
      | (arg,_) :: other_args ->
        Printf.bprintf oc " %s" arg;
        let rec iter list =
          match list with
            [] -> ()
          | (arg,arg_flags) :: tail ->
            if List.mem VA_ARRAY arg_flags
              || List.mem MAYBE_ARG arg_flags then
              Printf.bprintf oc ", ..."
            else begin
              Printf.bprintf oc ", %s" arg;
              iter tail
            end
        in
        iter other_args
    end;
    Printf.bprintf oc " );\n";
  ) functions

let initialization_function oc functions =
  Printf.bprintf oc "\n\n\n";
  Printf.bprintf oc "static void init_functions(void){";
  for i = 0 to 15 do
    Printf.bprintf oc "   function_digest[%d] = %d;\n" i
      (int_of_char digest.[i])
  done;
  Array.iter (fun (result_type, fun_name, args, flags) ->
    Printf.bprintf oc
      "   libc_%s = dlsym(RTLD_NEXT, \"%s\");\n" fun_name fun_name;
  ) functions;
  Printf.bprintf oc "}\n"

let arg_of_type oc arg_flag arg_type arg_flags arg_name =
  if List.mem arg_flag arg_flags then
    if List.mem VA_ARRAY arg_flags then
      Printf.bprintf oc "      call_msg_stringsNULL(%s);\n" arg_name
    else
      match arg_type with
        (* int *)
        "int"
      | "uid_t" | "gid_t" | "void" | "mode_t"
      (* long *)
      | "pid_t" | "time_t"
      | "size_t" | "ssize_t"
        ->
        Printf.bprintf oc "      call_msg_long(%s);\n" arg_name
      | "FILE *"
        ->
        Printf.bprintf oc "      call_msg_FILEP(%s);\n" arg_name
      | "DIR *"
        ->
        Printf.bprintf oc "      call_msg_DIRP(%s);\n" arg_name
      | "char *"
      | "const char *"
        ->
        Printf.bprintf oc "      call_msg_string0(%s);\n" arg_name
      | "struct dirent *"
        ->
        Printf.bprintf oc "      call_msg_direntp(%s);\n" arg_name
      | "char * const *"
        ->
        Printf.bprintf oc "      call_msg_stringsNULL(%s);\n" arg_name
      | "struct stat *"
        ->
        Printf.bprintf oc "      call_msg_stat(%s);\n" arg_name
      | "struct stat64 *"
        ->
        Printf.bprintf oc "      call_msg_stat64(%s);\n" arg_name
      | "__off64_t" | "off_t"
        ->
        Printf.bprintf oc "      call_msg_ulong(%s);\n" arg_name
      | s ->
        Printf.fprintf stderr "Error: unknown message type %S\n%!" arg_type;
        exit 2


let printf_format_of_type oc arg_type sep =
  match arg_type with
    "int"
  | "uid_t" | "gid_t" | "void"
    -> Printf.bprintf oc " %s%%d" sep
  | "pid_t"
    -> Printf.bprintf oc " %sPID(%%d)" sep
  | "FILE *"
    -> Printf.bprintf oc " %sFILE(%%d)" sep
  | "DIR *"
    -> Printf.bprintf oc " %sDIR(%%d)" sep
  | "size_t" | "off_t" | "ssize_t"
    -> Printf.bprintf oc " %s%%ld" sep
  | "char *"
  | "const char *"
    -> Printf.bprintf oc " %s\\\"%%s\\\"" sep
  | "struct dirent *"
    -> Printf.bprintf oc " %sDIRENT(\\\"%%s\\\")" sep
  | _ -> Printf.bprintf oc " %s_" sep

let printf_value_of_type oc arg_type arg_name =
  match arg_type with
  | "int" | "void"
  | "uid_t" | "gid_t" | "size_t" | "off_t" | "ssize_t" | "pid_t"
  | "char *"
  | "const char *" -> Printf.bprintf oc " ,%s" arg_name
  | "DIR *"
  | "FILE *"
  | "struct dirent *" ->
    Printf.bprintf oc " ,printer_%s" arg_name
  | _ -> ()

let declaration_of_type_printer oc arg_type arg_name =
  match arg_type with
  | "DIR *"
  | "FILE *" ->
    Printf.bprintf oc "   int printer_%s = -1;\n"
      arg_name
  | "struct dirent *" ->
    Printf.bprintf oc "   char * printer_%s = \"NULL\";\n"
      arg_name
  | _ -> ()

let initialization_of_printer oc arg_type arg_name =
  match arg_type with
  | "FILE *" ->
    Printf.bprintf oc "   if (%s != NULL)\n" arg_name;
    Printf.bprintf oc "      printer_%s = fileno(%s);\n" arg_name arg_name;
  | "DIR *" ->
    Printf.bprintf oc "   if (%s != NULL)\n" arg_name;
    Printf.bprintf oc "      printer_%s = dirfd(%s);\n" arg_name arg_name;
  | "struct dirent *" ->
    Printf.bprintf oc "   if (%s != NULL)\n" arg_name;
    Printf.bprintf oc "      printer_%s = %s->d_name;\n" arg_name arg_name;
  | _ -> ()


let function_implementations oc functions =
  Printf.bprintf oc "\n\n\n";
  Array.iteri (fun fun_id (result_type, fun_name, args, flags) ->
    if not (List.mem NO_IMPLEMENTATION flags) then begin
      Printf.bprintf oc "\n\n";

      (* 1. prototype of the function *)
      Printf.bprintf oc
        "%s %s ("
        result_type fun_name;
      let counter = ref 96 in
      let args = List.map (fun (arg, arg_flags) ->
        incr counter;
        arg, arg_flags, "arg" ^ String.make 1 (char_of_int !counter)) args in

      let va_args = ref None in
      let va_array = ref None in
      begin
        match args with
          [] -> Printf.bprintf oc "void"
        | (arg_type, arg_flags, arg_name) :: other_args ->
          Printf.bprintf oc " %s %s" arg_type arg_name;
          let rec iter prev_name list =
            match list with
              [] -> ()
            | (arg_type, arg_flags, arg_name) :: other_args ->
              if List.mem MAYBE_ARG arg_flags then begin
                Printf.bprintf oc ", ...";
                va_args := Some (arg_type, arg_flags, arg_name, prev_name, other_args)
              end
              else
                if List.mem VA_ARRAY arg_flags then begin
                  Printf.bprintf oc ", %s %s0, ..." arg_type arg_name;
                  va_array := Some (arg_type, arg_flags, arg_name, prev_name, other_args)
                end else begin
                  Printf.bprintf oc ", %s %s" arg_type arg_name;
                  iter arg_name other_args
                end
          in
          iter arg_name other_args
      end;
      Printf.bprintf oc " )\n";
      (* 2. body of the function *)
      Printf.bprintf oc "{\n";
      Printf.bprintf oc "   int fun_id = %d;\n" fun_id;
      Printf.bprintf oc "   int keep_errno;\n";

      (* 2.1 local variables *)
      if result_type <> "void" then
        Printf.bprintf oc "   %s res;\n" result_type;

      (*
        List.iter (fun (arg_type, arg_flags, arg_name) ->
        declaration_of_type_printer oc arg_type arg_name
        ) args;
        declaration_of_type_printer oc result_type "res";
      *)

      (* extraction of va_arg arguments *)
      begin
        match !va_args with
          None -> ()
        | Some (arg_type, arg_flags, arg_name, prev_name, other_args) ->
          Printf.bprintf oc "   va_list ap;\n";
          Printf.bprintf oc "   %s %s;\n" arg_type arg_name;
          Printf.bprintf oc "   va_start(ap, %s);\n" prev_name;
          Printf.bprintf oc "   %s = va_arg(ap,  %s);\n"  arg_name arg_type;
          Printf.bprintf oc "   va_end(ap);\n"
      end;

      (* extraction of va_array arguments *)
      begin
        match !va_array with
          None -> ()
        | Some (arg_type, arg_flags, arg_name, prev_name, other_args) ->
          Printf.bprintf oc "   char * * %s;\n"  arg_name;
          List.iter (fun (arg_type, arg_flags, arg_name) ->
            Printf.bprintf oc "   %s %s;\n" arg_type arg_name;
          ) other_args;
          Printf.bprintf oc "   {\n";
          Printf.bprintf oc "     va_list ap;\n";
          Printf.bprintf oc "     char * arg;\n";
          Printf.bprintf oc "     int nargs = 1;\n";
          Printf.bprintf oc "     va_start(ap, %s0);\n" arg_name;
          Printf.bprintf oc "     arg = (char*) %s0;\n" arg_name;
          Printf.bprintf oc "     while(arg){\n";
          Printf.bprintf oc "       arg = va_arg(ap, char*);\n";
          Printf.bprintf oc "       nargs++;\n";
          Printf.bprintf oc "     }\n";
          Printf.bprintf oc "     va_end(ap);\n";
          Printf.bprintf oc "     %s = malloc(nargs * sizeof(char*));\n" arg_name;
          Printf.bprintf oc "     nargs = 1;\n";
          Printf.bprintf oc "     va_start(ap, %s0);\n" arg_name;

          Printf.bprintf oc "     arg = (char*) %s0;\n" arg_name;
          Printf.bprintf oc "     %s[0] = arg;\n" arg_name;
          Printf.bprintf oc "     while(arg){\n";
          Printf.bprintf oc "       arg = va_arg(ap, char*);\n";
          Printf.bprintf oc "       %s[nargs] = arg;\n" arg_name;
          Printf.bprintf oc "       nargs++;\n";
          Printf.bprintf oc "     }\n";
          List.iter (fun (arg_type, arg_flags, arg_name) ->
            Printf.bprintf oc "     %s = va_arg(ap, %s);\n" arg_name arg_type;
          ) other_args;
          Printf.bprintf oc "     va_end(ap);\n";
          Printf.bprintf oc "   }\n";
      end;

      (*
      (* arguments to printers *)
        List.iter (fun (arg_type, arg_flags, arg_name) ->
        initialization_of_printer oc arg_type arg_name
        ) args;
      *)

      Printf.bprintf oc "   init();\n";

      (* send message *)
      begin
        Printf.bprintf oc "   if ( (function_bitmap[%d] & 1) != 0 ){\n" fun_id;
        Printf.bprintf oc "      call_msg_init();\n";

        List.iter (fun (arg_type, arg_flags, arg_name) ->
          arg_of_type oc SEND_INPUT arg_type arg_flags arg_name
        ) args;

        Printf.bprintf oc "      send_call(mq_P2W, PROTOCOL_P2W_BeforeCallMsg, fun_id);\n";
        Printf.bprintf oc "      if ( (function_bitmap[%d] & 4) != 0 ){\n" fun_id;
        Printf.bprintf oc "        suspend_on_recv(mq_W2P, fun_id);\n";
        Printf.bprintf oc "      }\n";
        Printf.bprintf oc "   }\n";
      end;

      (*
      (* print BEFORE call message *)
        begin (* print before call *)

        Printf.bprintf oc "   fprintf(socket, \"\\n%%d: BEFORE %s(" fun_name;
        let first = ref true in
        List.iter (fun (arg_type, arg_flags, arg_name) ->
        printf_format_of_type oc arg_type (if !first then "" else ",");
        first := false;
        ) args;
        Printf.bprintf oc ")";
        Printf.bprintf oc "\\n\", pid";
        List.iter (fun (arg_type, arg_flags, arg_name) ->
        printf_value_of_type oc arg_type arg_name
        ) args;
        Printf.bprintf oc ");\n";
        Printf.bprintf oc "   fflush(socket);\n";
        end;
      *)

      if List.mem KILL_BEFORE flags then begin
        Printf.bprintf oc "   fprintf(socket, \"\\n%%d: bad function call. Suicide\\n\", pid);\n";
        Printf.bprintf oc "   libc_exit(2);\n";
      end;

      if List.mem CLOSE_BEFORE flags then begin
        Printf.bprintf oc "   finish();\n";
      end;

      (* call real function *)

      begin
        let call_name = ref (Printf.sprintf "libc_%s" fun_name) in
        List.iter (function
        | REPLACE_CALL_BY s -> call_name := s
        | _ -> ()
        ) flags;
        Printf.bprintf oc "   %s%s("
          (if result_type <> "void" then "res = " else "") !call_name;
      end;
      begin
        match args with
          [] -> ()
        | (_arg_type, arg_flags, arg_name) :: other_args ->
          Printf.bprintf oc " %s" arg_name;
          List.iter (fun (arg_type, arg_flags, arg_name) ->
            if arg_type <> "..." then
              Printf.bprintf oc ", %s" arg_name
          ) other_args
      end;
      Printf.bprintf oc "      );\n";
      Printf.bprintf oc "      keep_errno = errno;\n";

      begin match !va_array with
        None -> ()
      | Some (_, _, arg_name, _, _) ->
        Printf.bprintf oc "   free(%s);\n" arg_name
      end;

      if List.mem UPDATE_PID flags then begin
        Printf.bprintf oc "   pid = getpid();\n";
      end;

      (* send final message *)
      begin
        Printf.bprintf oc "   if ( (function_bitmap[%d] & 2) != 0 ){\n" fun_id;
        Printf.bprintf oc "      call_msg_init();\n";

        if List.mem INT_OF_STRING_RESULT flags then
          Printf.bprintf oc "      call_msg_long(res == NULL ? -1 : strlen(res));\n"
        else
          if result_type <> "void" then
            arg_of_type oc SEND_OUTPUT result_type [SEND_OUTPUT] "res";

        let check_output = ref "1" in
        List.iter (function
      CHECK_FOR_OUTPUT s -> check_output := s
        | _ -> ()
        ) flags;
        Printf.bprintf oc "      if( %s ){\n" !check_output;
        List.iter (fun (arg_type, arg_flags, arg_name) ->
          arg_of_type oc SEND_OUTPUT arg_type arg_flags arg_name
        ) args;
        if List.mem SEND_CWD flags then begin
          Printf.bprintf oc "     call_msg_getcwd();\n";
        end;
        Printf.bprintf oc "      }\n";
        Printf.bprintf oc "      call_msg_errno(keep_errno);\n";

        Printf.bprintf oc "      send_call(mq_P2W, PROTOCOL_P2W_AfterCallMsg, fun_id);\n";
        Printf.bprintf oc "   }\n";
      end;


      if not (List.mem NO_RETURN flags) then
        Printf.bprintf oc "   return%s;\n" (if result_type <> "void" then " res" else "");

      Printf.bprintf oc "}\n";
    end
  ) functions

let command s =
  Printf.eprintf "\t%s\n%!" s;
  let status =  Sys.command s in
  if status <> 0 then begin
    Printf.eprintf "WatchInstall Error: Command %S failed with status %d.\n%!" s status;
    exit 2
  end

let subcmd_init () = ()
let subcmd_spec = {
  subcmd_list = [];
  subcmd_usage = [ " install ocp_watcher.so in ~/.ocp-watch" ];
  subcmd_help = [];
}

let subcmd_main args =
  assert (args = [||]);
  let watch_dir = Filename.concat (Sys.getenv "HOME") ".ocp-watch" in
  command "mkdir -p $HOME/.ocp-watch";
  Sys.chdir watch_dir;

  let compile_md5 =
    not (Sys.file_exists "md5.c") ||
      Digest.file "md5.c" <> Digest.string WatchSource.md5
  in
  if compile_md5 then begin
    let oc = open_out "md5.c" in
    output_string oc WatchSource.md5;
    close_out oc;
    command "gcc -Wall -g -fPIC -c -o md5.o md5.c";
  end;

  let ocp_watcher_source =
    let oc = Buffer.create 1000 in
    Buffer.add_string oc WatchSource.header;
    Printf.bprintf oc "#line %d \"%s/ocp_watcher.c\"\n"
      (WatchSource.header_nlines + 3) watch_dir;
    function_prototypes oc functions;
    initialization_function oc functions;
    function_implementations oc functions;
    Buffer.add_string oc WatchSource.trailer;
    Buffer.contents oc
  in
  let compile_watcher =
    not (Sys.file_exists "ocp_watcher.c") ||
      Digest.file "ocp_watcher.c" <> Digest.string ocp_watcher_source
  in
  if compile_watcher then begin
    let oc = open_out "ocp_watcher.c" in
    output_string oc ocp_watcher_source;
    close_out oc;
    command "gcc -Wall -g -fPIC -c -o ocp_watcher.o ocp_watcher.c";
  end;

  if compile_md5 || compile_watcher then
    command "ld -g -shared -o ocp_watcher.so md5.o ocp_watcher.o -ldl";

  ()
